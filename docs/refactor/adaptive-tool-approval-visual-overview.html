<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Adaptive Tool Approval Architecture Overview</title>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Sora:wght@400;500;600;700;800&family=IBM+Plex+Mono:wght@400;500&display=swap"
      rel="stylesheet"
    />
    <style>
      :root {
        --bg: #0e1118;
        --bg-alt: #1a2433;
        --panel: #1e2838;
        --panel-soft: #273348;
        --ink: #f0f5ff;
        --muted: #b8c9e8;
        --accent: #4dd4ac;
        --accent-2: #5db4ff;
        --accent-3: #ffbb55;
        --danger: #ff6f7d;
        --ok: #61e4a5;
        --border: rgba(255, 255, 255, 0.16);
        --shadow: 0 24px 60px rgba(4, 8, 15, 0.48);
        --radius: 16px;
      }

      * {
        box-sizing: border-box;
      }

      html,
      body {
        margin: 0;
        min-height: 100%;
        color: var(--ink);
        font-family: "Sora", system-ui, sans-serif;
        background:
          radial-gradient(1100px 700px at 12% -10%, rgba(77, 212, 172, 0.18), transparent 55%),
          radial-gradient(900px 560px at 110% 16%, rgba(88, 168, 255, 0.19), transparent 56%),
          linear-gradient(180deg, #0b1017 0%, #0e1118 100%);
      }

      .wrap {
        width: min(1360px, 100% - 2.2rem);
        margin: 1.1rem auto 2.8rem;
        display: grid;
        gap: 1rem;
      }

      .hero {
        background:
          linear-gradient(
            130deg,
            rgba(77, 212, 172, 0.18),
            rgba(88, 168, 255, 0.14) 45%,
            rgba(255, 187, 85, 0.1)
          ),
          radial-gradient(circle at 80% 20%, rgba(77, 212, 172, 0.08) 0%, transparent 50%),
          var(--panel);
        border: 1px solid var(--border);
        box-shadow: var(--shadow);
        border-radius: 22px;
        padding: 1.3rem 1.3rem 1.1rem;
      }

      .hero-top {
        display: flex;
        gap: 0.8rem;
        flex-wrap: wrap;
        align-items: center;
        justify-content: space-between;
      }

      .badge {
        display: inline-flex;
        align-items: center;
        gap: 0.45rem;
        border: 1px solid rgba(255, 255, 255, 0.25);
        border-radius: 999px;
        color: #e5f0ff;
        font-size: 0.75rem;
        font-weight: 600;
        letter-spacing: 0.04em;
        padding: 0.3rem 0.6rem;
        text-transform: uppercase;
        background: rgba(255, 255, 255, 0.08);
      }

      .hero h1 {
        margin: 0.55rem 0 0.4rem;
        font-size: clamp(1.2rem, 2.6vw, 2rem);
        line-height: 1.18;
      }

      .hero p {
        margin: 0;
        color: #d4e2f8;
        max-width: 80ch;
        font-size: 0.94rem;
        line-height: 1.6;
      }

      .stats {
        margin-top: 0.95rem;
        display: grid;
        grid-template-columns: repeat(5, minmax(0, 1fr));
        gap: 0.55rem;
      }

      .stat {
        padding: 0.75rem 0.7rem;
        border-radius: 12px;
        background:
          radial-gradient(circle at 40% 30%, rgba(88, 168, 255, 0.06) 0%, transparent 70%),
          rgba(10, 18, 30, 0.6);
        border: 1px solid rgba(255, 255, 255, 0.15);
      }

      .stat strong {
        display: block;
        font-size: 1.08rem;
        color: #e8f2ff;
        margin-bottom: 0.2rem;
      }

      .stat span {
        color: var(--muted);
        font-size: 0.76rem;
        line-height: 1.4;
      }

      .toolbar {
        background:
          radial-gradient(circle at 15% 50%, rgba(77, 212, 172, 0.05) 0%, transparent 60%),
          var(--panel);
        border: 1px solid var(--border);
        border-radius: var(--radius);
        padding: 0.85rem;
        display: grid;
        gap: 0.7rem;
      }

      .toolbar-row {
        display: flex;
        gap: 0.6rem;
        flex-wrap: wrap;
        align-items: center;
      }

      .search-wrap {
        position: relative;
        flex: 1;
        min-width: 230px;
      }

      #search {
        width: 100%;
        border: 1px solid var(--border);
        border-radius: 10px;
        background: var(--bg-alt);
        color: var(--ink);
        font: inherit;
        font-size: 0.88rem;
        padding: 0.66rem 2.4rem 0.66rem 0.75rem;
        transition: all 160ms ease;
      }

      #search::placeholder {
        color: #8fa8cc;
      }

      #search:focus {
        outline: none;
        border-color: rgba(88, 168, 255, 0.7);
        box-shadow: 0 0 0 3px rgba(88, 168, 255, 0.25);
        background: var(--panel);
      }

      .search-hint {
        position: absolute;
        right: 0.54rem;
        top: 50%;
        transform: translateY(-50%);
        color: var(--muted);
        font-size: 0.72rem;
        pointer-events: none;
        font-family: "IBM Plex Mono", monospace;
      }

      .pill-row {
        display: flex;
        flex-wrap: wrap;
        gap: 0.45rem;
      }

      .pill {
        border: 1px solid var(--border);
        border-radius: 999px;
        background: var(--bg-alt);
        color: #dae5f7;
        font-size: 0.78rem;
        font-weight: 600;
        padding: 0.4rem 0.7rem;
        cursor: pointer;
        transition:
          transform 140ms ease,
          border-color 140ms ease,
          color 140ms ease,
          background 140ms ease;
      }

      .pill:hover {
        background: var(--panel-soft);
        border-color: rgba(255, 255, 255, 0.22);
      }

      .pill.active {
        border-color: rgba(77, 212, 172, 0.8);
        color: #e9fff7;
        transform: translateY(-1px);
        background:
          conic-gradient(
            from 180deg at 50% 50%,
            rgba(77, 212, 172, 0.15) 0deg,
            rgba(88, 168, 255, 0.15) 120deg,
            rgba(77, 212, 172, 0.15) 240deg,
            rgba(77, 212, 172, 0.15) 360deg
          ),
          var(--bg-alt);
        box-shadow: 0 0 20px rgba(77, 212, 172, 0.3);
        animation: shimmer 3s ease-in-out infinite;
      }

      @keyframes shimmer {
        0%,
        100% {
          box-shadow: 0 0 20px rgba(77, 212, 172, 0.3);
        }
        50% {
          box-shadow: 0 0 30px rgba(77, 212, 172, 0.5);
        }
      }

      @keyframes pulse-glow {
        0%,
        100% {
          filter: brightness(1);
        }
        50% {
          filter: brightness(1.15);
        }
      }

      @keyframes connector-pulse {
        0%,
        100% {
          opacity: 0.7;
          transform: scale(1);
        }
        50% {
          opacity: 1;
          transform: scale(1.1);
        }
      }

      .grid {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 1rem;
      }

      .panel {
        background:
          radial-gradient(circle at 20% 30%, rgba(88, 168, 255, 0.08) 0%, transparent 50%),
          radial-gradient(circle at 80% 70%, rgba(77, 212, 172, 0.06) 0%, transparent 50%),
          var(--panel);
        border: 1px solid var(--border);
        border-radius: var(--radius);
        box-shadow: var(--shadow);
      }

      .graph-shell {
        padding: 0.7rem 0.7rem 0.9rem;
      }

      .graph-head {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 0.8rem;
        margin-bottom: 0.65rem;
      }

      .graph-title {
        margin: 0;
        font-size: 0.98rem;
        color: #e8f2ff;
        font-weight: 600;
      }

      .graph-actions {
        display: flex;
        gap: 0.5rem;
      }

      button.ghost {
        border: 1px solid var(--border);
        border-radius: 10px;
        background: var(--bg-alt);
        color: #dce8f9;
        font: inherit;
        font-size: 0.75rem;
        font-weight: 600;
        padding: 0.42rem 0.62rem;
        cursor: pointer;
        transition: all 160ms ease;
      }

      button.ghost:hover {
        background: var(--panel-soft);
        border-color: rgba(255, 255, 255, 0.25);
        transform: translateY(-1px);
      }

      button.ghost:focus-visible,
      .pill:focus-visible {
        outline: 2px solid var(--accent-2);
        outline-offset: 2px;
      }

      .graph-wrap {
        border: 1px solid rgba(255, 255, 255, 0.12);
        border-radius: 12px;
        overflow: hidden;
        background:
          radial-gradient(circle at 30% 40%, rgba(88, 168, 255, 0.08) 0%, transparent 50%),
          radial-gradient(circle at 70% 60%, rgba(77, 212, 172, 0.06) 0%, transparent 50%),
          linear-gradient(180deg, #14192a, #101622);
      }

      #systemGraph {
        width: 100%;
        height: 560px;
        display: block;
      }

      .legend {
        margin-top: 0.6rem;
        display: flex;
        gap: 0.6rem;
        flex-wrap: wrap;
      }

      .legend-item {
        display: inline-flex;
        align-items: center;
        gap: 0.45rem;
        color: #d4e2f8;
        font-size: 0.74rem;
        border: 1px solid rgba(255, 255, 255, 0.18);
        border-radius: 999px;
        padding: 0.32rem 0.58rem;
        background: rgba(255, 255, 255, 0.04);
      }

      .dot {
        width: 0.64rem;
        height: 0.64rem;
        border-radius: 99px;
      }

      .detail {
        padding: 0.86rem;
        display: grid;
        grid-template-rows: auto auto auto 1fr;
        gap: 0.7rem;
        min-height: 0;
      }

      .detail h2 {
        margin: 0;
        font-size: 1.12rem;
        color: #f0f5ff;
        line-height: 1.3;
      }

      .detail-sub {
        color: #c5d6f0;
        font-size: 0.82rem;
        line-height: 1.5;
      }

      .detail-chips {
        display: flex;
        gap: 0.45rem;
        flex-wrap: wrap;
      }

      .chip {
        border-radius: 999px;
        border: 1px solid rgba(255, 255, 255, 0.2);
        padding: 0.28rem 0.58rem;
        font-size: 0.74rem;
        color: #e5f0ff;
        background: var(--panel-soft);
        font-weight: 500;
      }

      .detail-scroll {
        overflow: auto;
        min-height: 260px;
        max-height: 560px;
        padding-right: 0.15rem;
      }

      .detail-block {
        padding: 0.75rem;
        border: 1px solid rgba(255, 255, 255, 0.14);
        border-radius: 12px;
        background:
          radial-gradient(circle at 10% 20%, rgba(88, 168, 255, 0.06) 0%, transparent 60%),
          rgba(20, 30, 45, 0.92);
        margin-bottom: 0.65rem;
      }

      .detail-block h3 {
        margin: 0 0 0.45rem;
        font-size: 0.84rem;
        color: #e5f0ff;
        font-weight: 600;
      }

      .detail-block p,
      .detail-block li {
        margin: 0;
        color: #d0ddf3;
        font-size: 0.79rem;
        line-height: 1.55;
      }

      .detail-block ul {
        margin: 0;
        padding-left: 1.2rem;
      }

      .detail-block li {
        margin-bottom: 0.3rem;
      }

      .detail-block li:last-child {
        margin-bottom: 0;
      }

      .data-card-grid {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 0.9rem;
        margin-bottom: 0.9rem;
      }

      .full-width-card {
        grid-column: 1 / -1;
        margin-top: 0;
      }

      .subpanel {
        padding: 1rem;
      }

      .subpanel p {
        margin: 0;
      }

      .subpanel h3 {
        margin: 0 0 0.75rem;
        font-size: 1.05rem;
        color: #e8f2ff;
        font-weight: 700;
        letter-spacing: -0.01em;
      }

      .flow-grid {
        display: flex;
        flex-direction: column;
        gap: 0;
        position: relative;
      }

      .flow-grid::before {
        content: "";
        position: absolute;
        left: 2.2rem;
        top: 2.8rem;
        bottom: 2.8rem;
        width: 2px;
        background: linear-gradient(
          180deg,
          rgba(77, 212, 172, 0.7) 0%,
          rgba(88, 168, 255, 0.7) 35%,
          rgba(255, 187, 85, 0.6) 60%,
          rgba(88, 168, 255, 0.7) 85%,
          rgba(97, 228, 165, 0.7) 100%
        );
        border-radius: 2px;
        box-shadow: 0 0 12px rgba(88, 168, 255, 0.4);
        z-index: 1;
      }

      .flow-row {
        position: relative;
        display: flex;
        align-items: center;
        margin-bottom: 0.4rem;
        padding-left: 4rem;
        gap: 0;
      }

      .flow-row::before {
        content: "";
        position: absolute;
        left: calc(2.2rem - 0.6rem);
        top: calc(50% - 0.6rem);
        width: 1.2rem;
        height: 1.2rem;
        border-radius: 50%;
        background: var(--accent-2);
        box-shadow: 0 0 8px rgba(88, 168, 255, 0.6);
        z-index: 2;
        animation: connector-pulse 3s ease-in-out infinite;
      }

      .flow-row:first-child::before {
        background: var(--accent);
        box-shadow: 0 0 8px rgba(77, 212, 172, 0.6);
        animation-delay: 0s;
      }

      .flow-row:nth-child(2)::before {
        animation-delay: 0.3s;
      }
      .flow-row:nth-child(3)::before {
        animation-delay: 0.6s;
      }
      .flow-row:nth-child(4)::before {
        animation-delay: 0.9s;
      }
      .flow-row:nth-child(5)::before {
        animation-delay: 1.2s;
      }
      .flow-row:nth-child(6)::before {
        animation-delay: 1.5s;
      }

      .flow-row:last-child::before {
        background: var(--ok);
        box-shadow: 0 0 8px rgba(97, 228, 165, 0.6);
        animation-delay: 1.8s;
      }

      .flow-row.active::before {
        background: var(--accent);
        box-shadow: 0 0 0 3px rgba(77, 212, 172, 0.6);
        animation: pulse-glow 2s ease-in-out infinite;
      }

      .flow-step {
        position: relative;
        border: 1px solid rgba(255, 255, 255, 0.14);
        border-radius: 14px;
        background:
          radial-gradient(circle at 30% 40%, rgba(88, 168, 255, 0.05) 0%, transparent 70%),
          rgba(15, 24, 38, 0.88);
        padding: 0.65rem 0.9rem;
        cursor: pointer;
        min-height: auto;
        display: flex;
        flex-direction: column;
        justify-content: center;
        flex: 0 0 48%;
        transition:
          border-color 140ms ease,
          transform 140ms ease,
          background 140ms ease,
          box-shadow 140ms ease;
      }

      .flow-step:hover {
        border-color: rgba(88, 168, 255, 0.6);
        box-shadow: 0 2px 12px rgba(88, 168, 255, 0.2);
      }

      .flow-step.active {
        border-color: rgba(77, 212, 172, 0.9);
        background:
          conic-gradient(
            from 45deg at 50% 50%,
            rgba(77, 212, 172, 0.2) 0deg,
            rgba(88, 168, 255, 0.2) 90deg,
            rgba(77, 212, 172, 0.2) 180deg,
            rgba(88, 168, 255, 0.2) 270deg,
            rgba(77, 212, 172, 0.2) 360deg
          ),
          rgba(24, 46, 58, 0.95);
        box-shadow: 0 4px 24px rgba(77, 212, 172, 0.4);
        animation: shimmer 3s ease-in-out infinite;
      }

      .flow-step strong {
        display: block;
        font-size: 0.88rem;
        color: #e8f2ff;
        font-weight: 600;
        margin-bottom: 0.3rem;
      }

      .flow-step-hint {
        color: rgba(155, 180, 218, 0.72);
        font-size: 0.7rem;
        line-height: 1.35;
        display: block;
        letter-spacing: 0.01em;
      }

      .mechanism-badge {
        display: inline-flex;
        align-items: center;
        gap: 0.3rem;
        padding: 0.22rem 0.45rem;
        border-radius: 999px;
        font-size: 0.65rem;
        font-weight: 700;
        text-transform: uppercase;
        letter-spacing: 0.03em;
        white-space: nowrap;
        margin-left: 0.5rem;
      }

      .mechanism-badge.rules {
        background: rgba(77, 212, 172, 0.2);
        color: #9fffcc;
        border: 1px solid rgba(77, 212, 172, 0.4);
      }

      .mechanism-badge.llm {
        background: rgba(88, 168, 255, 0.2);
        color: #9dd0ff;
        border: 1px solid rgba(88, 168, 255, 0.4);
      }

      .mechanism-badge.human {
        background: rgba(255, 187, 85, 0.2);
        color: #ffe0a8;
        border: 1px solid rgba(255, 187, 85, 0.4);
      }

      .mechanism-badge.hybrid {
        background: rgba(176, 139, 255, 0.2);
        color: #d0b8ff;
        border: 1px solid rgba(176, 139, 255, 0.4);
      }

      .mechanism-icon {
        width: 0.6rem;
        height: 0.6rem;
        border-radius: 50%;
        display: inline-block;
        flex-shrink: 0;
      }

      .mechanism-badge.rules .mechanism-icon {
        background: #9fffcc;
        box-shadow: 0 0 6px rgba(77, 212, 172, 0.6);
      }

      .mechanism-badge.llm .mechanism-icon {
        background: #9dd0ff;
        box-shadow: 0 0 6px rgba(88, 168, 255, 0.6);
      }

      .mechanism-badge.human .mechanism-icon {
        background: #ffe0a8;
        box-shadow: 0 0 6px rgba(255, 187, 85, 0.6);
      }

      .mechanism-badge.hybrid .mechanism-icon {
        background: #d0b8ff;
        box-shadow: 0 0 6px rgba(176, 139, 255, 0.6);
      }

      .flow-connectors {
        display: flex;
        flex-direction: column;
        gap: 0.32rem;
        flex: 1;
        min-width: 0;
        justify-content: center;
        padding-left: 8px;
      }

      /* Tree bracket layout for 3+ resources */
      .flow-connectors.has-trunk {
        position: relative;
        padding-left: 16px;
      }

      /* Vertical trunk line connecting all resource branches */
      .flow-connectors.has-trunk::before {
        content: "";
        position: absolute;
        left: 13px;
        top: 0;
        bottom: 0;
        width: 2px;
        background: linear-gradient(
          180deg,
          rgba(88, 168, 255, 0.35) 0%,
          rgba(77, 212, 172, 0.25) 50%,
          rgba(88, 168, 255, 0.35) 100%
        );
        border-radius: 1px;
        box-shadow: 0 0 5px rgba(88, 168, 255, 0.15);
      }

      /* Horizontal stub from card edge to trunk */
      .flow-connectors.has-trunk::after {
        content: "";
        position: absolute;
        left: 0;
        top: 50%;
        transform: translateY(-50%);
        width: 14px;
        height: 2px;
        background: linear-gradient(
          90deg,
          rgba(88, 168, 255, 0.4) 0%,
          rgba(77, 212, 172, 0.3) 100%
        );
        border-radius: 1px;
        box-shadow: 0 0 4px rgba(88, 168, 255, 0.12);
      }

      .flow-connector-line {
        display: flex;
        align-items: center;
        gap: 0;
        position: relative;
      }

      .connector-track {
        width: 38px;
        height: 2px;
        background: linear-gradient(
          90deg,
          rgba(88, 168, 255, 0.4) 0%,
          rgba(77, 212, 172, 0.25) 100%
        );
        border-radius: 1px;
        position: relative;
        flex-shrink: 0;
        box-shadow: 0 0 4px rgba(88, 168, 255, 0.15);
        overflow: visible;
      }

      .connector-track::after {
        content: "";
        position: absolute;
        width: 6px;
        height: 6px;
        border-radius: 50%;
        top: 50%;
        transform: translateY(-50%);
        background: rgba(88, 168, 255, 0.85);
        box-shadow: 0 0 8px rgba(88, 168, 255, 0.6);
        animation: travel-orb 2.4s ease-in-out infinite;
      }

      .flow-connector-line:nth-child(2) .connector-track::after {
        animation-delay: 0.35s;
      }
      .flow-connector-line:nth-child(3) .connector-track::after {
        animation-delay: 0.7s;
      }
      .flow-connector-line:nth-child(4) .connector-track::after {
        animation-delay: 1.05s;
      }
      .flow-connector-line:nth-child(5) .connector-track::after {
        animation-delay: 1.4s;
      }

      @keyframes travel-orb {
        0%,
        6% {
          left: -3px;
          background: rgba(88, 168, 255, 0.85);
          box-shadow: 0 0 8px rgba(88, 168, 255, 0.6);
        }
        45% {
          background: rgba(77, 212, 172, 0.95);
          box-shadow: 0 0 12px rgba(77, 212, 172, 0.7);
        }
        65% {
          left: calc(100% - 3px);
          background: rgba(77, 212, 172, 1);
          box-shadow: 0 0 14px rgba(77, 212, 172, 0.85);
        }
        66% {
          opacity: 0;
        }
        67% {
          left: -3px;
          opacity: 0;
        }
        75% {
          opacity: 1;
          background: rgba(88, 168, 255, 0.85);
          box-shadow: 0 0 8px rgba(88, 168, 255, 0.6);
        }
        100% {
          left: -3px;
        }
      }

      .resource-orb {
        display: inline-flex;
        align-items: center;
        gap: 0.28rem;
        padding: 0.26rem 0.55rem;
        border-radius: 999px;
        font-size: 0.66rem;
        font-weight: 500;
        color: #c8daf0;
        background:
          radial-gradient(circle at 30% 40%, rgba(88, 168, 255, 0.08) 0%, transparent 70%),
          rgba(12, 20, 32, 0.8);
        border: 1px solid rgba(88, 168, 255, 0.3);
        box-shadow:
          0 0 8px rgba(88, 168, 255, 0.12),
          inset 0 0 10px rgba(88, 168, 255, 0.04);
        white-space: nowrap;
        position: relative;
        transition: all 180ms ease;
        margin-left: 2px;
      }

      .resource-orb::before {
        content: "";
        width: 0.38rem;
        height: 0.38rem;
        border-radius: 50%;
        background: rgba(77, 212, 172, 0.5);
        box-shadow: 0 0 5px rgba(77, 212, 172, 0.35);
        flex-shrink: 0;
      }

      .resource-orb:hover {
        border-color: rgba(88, 168, 255, 0.65);
        color: #e5f0ff;
        box-shadow:
          0 0 14px rgba(88, 168, 255, 0.3),
          inset 0 0 12px rgba(88, 168, 255, 0.06);
        transform: translateY(-1px);
      }

      .risk-table {
        display: grid;
        gap: 0.45rem;
      }

      .risk-row {
        display: grid;
        grid-template-columns: 66px 1fr 148px;
        gap: 0.6rem;
        align-items: center;
        border: 1px solid rgba(255, 255, 255, 0.14);
        border-radius: 12px;
        padding: 0.5rem 0.65rem;
        background:
          radial-gradient(circle at 15% 50%, rgba(255, 187, 85, 0.04) 0%, transparent 70%),
          rgba(15, 24, 38, 0.88);
        cursor: pointer;
        transition:
          border-color 140ms ease,
          transform 140ms ease,
          background 140ms ease,
          box-shadow 140ms ease;
      }

      /* Risk-specific subtle background tints */
      .risk-row[data-id="R0"] {
        background:
          radial-gradient(circle at 12% 50%, rgba(97, 228, 165, 0.05) 0%, transparent 75%),
          rgba(15, 24, 38, 0.88);
      }

      .risk-row[data-id="R1"] {
        background:
          radial-gradient(circle at 12% 50%, rgba(88, 168, 255, 0.05) 0%, transparent 75%),
          rgba(15, 24, 38, 0.88);
      }

      .risk-row[data-id="R2"] {
        background:
          radial-gradient(circle at 12% 50%, rgba(184, 166, 255, 0.05) 0%, transparent 75%),
          rgba(15, 24, 38, 0.88);
      }

      .risk-row[data-id="R3"] {
        background:
          radial-gradient(circle at 12% 50%, rgba(255, 187, 85, 0.05) 0%, transparent 75%),
          rgba(15, 24, 38, 0.88);
      }

      .risk-row[data-id="R4"] {
        background:
          radial-gradient(circle at 12% 50%, rgba(255, 155, 155, 0.05) 0%, transparent 75%),
          rgba(15, 24, 38, 0.88);
      }

      .risk-row:hover {
        border-color: rgba(255, 255, 255, 0.22);
        transform: translateY(-1px);
        box-shadow: 0 2px 12px rgba(0, 0, 0, 0.3);
      }

      .risk-row.active {
        border-color: rgba(255, 187, 85, 0.9);
        background:
          conic-gradient(
            from 90deg at 50% 50%,
            rgba(255, 187, 85, 0.15) 0deg,
            rgba(88, 168, 255, 0.12) 120deg,
            rgba(255, 187, 85, 0.15) 240deg,
            rgba(255, 187, 85, 0.15) 360deg
          ),
          rgba(10, 19, 31, 0.92);
        box-shadow: 0 2px 16px rgba(255, 187, 85, 0.3);
        animation: shimmer 3s ease-in-out infinite;
      }

      .risk-tag {
        display: inline-grid;
        place-items: center;
        border-radius: 9px;
        font-size: 0.82rem;
        font-weight: 700;
        padding: 0.4rem 0;
      }

      .risk-tag.r0 {
        background: rgba(97, 228, 165, 0.25);
        color: #9fffcc;
        border: 1px solid rgba(97, 228, 165, 0.3);
      }

      .risk-tag.r1 {
        background: rgba(88, 168, 255, 0.25);
        color: #9dd0ff;
        border: 1px solid rgba(88, 168, 255, 0.3);
      }

      .risk-tag.r2 {
        background: rgba(96, 129, 255, 0.28);
        color: #b8c5ff;
        border: 1px solid rgba(96, 129, 255, 0.35);
      }

      .risk-tag.r3 {
        background: rgba(255, 187, 85, 0.26);
        color: #ffe0a8;
        border: 1px solid rgba(255, 187, 85, 0.35);
      }

      .risk-tag.r4 {
        background: rgba(255, 111, 125, 0.25);
        color: #ffb5bf;
        border: 1px solid rgba(255, 111, 125, 0.35);
      }

      .risk-main {
        line-height: 1.5;
        text-align: left;
      }

      /* Semantic title colors matching risk levels */
      .risk-title {
        display: block;
        font-size: 0.8rem;
        margin-bottom: 0.25rem;
        font-weight: 600;
      }

      .risk-title[data-risk="r0"] {
        color: #8df5bb;
      }
      .risk-title[data-risk="r1"] {
        color: #91d7ff;
      }
      .risk-title[data-risk="r2"] {
        color: #c4b5fd;
      }
      .risk-title[data-risk="r3"] {
        color: #ffd699;
      }
      .risk-title[data-risk="r4"] {
        color: #ffb3b3;
      }

      /* Tool chip pills */
      .risk-chips {
        display: flex;
        flex-wrap: wrap;
        gap: 0.3rem;
        margin-top: 0.15rem;
      }

      .tool-chip {
        display: inline-block;
        font-size: 0.68rem;
        font-family: "SF Mono", "Cascadia Code", "Fira Code", monospace;
        line-height: 1;
        padding: 0.2rem 0.45rem;
        border-radius: 9999px;
        background: rgba(88, 168, 255, 0.1);
        color: rgba(190, 215, 240, 0.85);
        border: 1px solid rgba(88, 168, 255, 0.15);
        white-space: nowrap;
      }

      /* Tint chips per risk level */
      .risk-row[data-id="R0"] .tool-chip {
        background: rgba(97, 228, 165, 0.1);
        border-color: rgba(97, 228, 165, 0.18);
        color: rgba(160, 235, 195, 0.9);
      }

      .risk-row[data-id="R1"] .tool-chip {
        background: rgba(88, 168, 255, 0.1);
        border-color: rgba(88, 168, 255, 0.18);
        color: rgba(170, 210, 255, 0.9);
      }

      .risk-row[data-id="R2"] .tool-chip {
        background: rgba(150, 140, 255, 0.1);
        border-color: rgba(150, 140, 255, 0.18);
        color: rgba(190, 185, 255, 0.9);
      }

      .risk-row[data-id="R3"] .tool-chip {
        background: rgba(255, 187, 85, 0.1);
        border-color: rgba(255, 187, 85, 0.18);
        color: rgba(255, 220, 170, 0.9);
      }

      .risk-row[data-id="R4"] .tool-chip {
        background: rgba(255, 111, 125, 0.1);
        border-color: rgba(255, 111, 125, 0.18);
        color: rgba(255, 190, 195, 0.9);
      }

      /* Semantic action colors based on severity */
      .risk-action {
        text-align: right;
        font-size: 0.75rem;
        font-weight: 600;
        line-height: 1.3;
      }

      .action-allow {
        color: #7fe8c3;
      }
      .action-allow-policy {
        color: #88e0ff;
      }
      .action-conditional {
        color: #ffd97a;
      }
      .action-approval {
        color: #ffb366;
      }
      .action-deny {
        color: #ff9999;
      }

      .timeline {
        position: relative;
        display: flex;
        gap: 0.8rem;
        padding-top: 1.3rem;
        padding-bottom: 0.3rem;
      }

      .timeline::before {
        content: "";
        position: absolute;
        left: 1.5rem;
        right: 1.5rem;
        top: 0.85rem;
        height: 3px;
        background: linear-gradient(
          90deg,
          rgba(77, 212, 172, 0.85) 0%,
          rgba(88, 168, 255, 0.65) 50%,
          rgba(255, 187, 85, 0.65) 100%
        );
        border-radius: 2px;
      }

      .phase {
        position: relative;
        flex: 1;
        border: 1px solid rgba(255, 255, 255, 0.14);
        border-radius: 12px;
        padding: 0.7rem 0.75rem;
        background:
          radial-gradient(circle at 50% 30%, rgba(88, 168, 255, 0.05) 0%, transparent 70%),
          rgba(16, 25, 40, 0.9);
        cursor: pointer;
        transition:
          border-color 140ms ease,
          transform 140ms ease,
          background 140ms ease,
          box-shadow 140ms ease;
        display: flex;
        flex-direction: column;
        min-width: 0;
      }

      .phase:hover {
        border-color: rgba(88, 168, 255, 0.5);
        box-shadow: 0 4px 16px rgba(88, 168, 255, 0.25);
      }

      .phase::before {
        content: "";
        position: absolute;
        left: calc(50% - 0.35rem);
        top: -1.2rem;
        width: 0.7rem;
        height: 0.7rem;
        border-radius: 50%;
        background: var(--accent-2);
        border: 3px solid rgba(16, 25, 40, 0.95);
        box-shadow: 0 0 0 2px rgba(88, 168, 255, 0.4);
        z-index: 2;
        animation: connector-pulse 3s ease-in-out infinite;
      }

      .phase:first-child::before {
        background: var(--accent);
        box-shadow: 0 0 0 2px rgba(77, 212, 172, 0.4);
        animation-delay: 0s;
      }

      .phase:nth-child(2)::before {
        animation-delay: 0.4s;
      }

      .phase:nth-child(3)::before {
        animation-delay: 0.8s;
      }

      .phase:nth-child(4)::before {
        animation-delay: 1.2s;
      }

      .phase:last-child::before {
        background: var(--accent-3);
        box-shadow: 0 0 0 2px rgba(255, 187, 85, 0.4);
        animation-delay: 1.6s;
      }

      .phase.active {
        border-color: rgba(88, 168, 255, 0.9);
        background:
          conic-gradient(
            from 135deg at 50% 50%,
            rgba(88, 168, 255, 0.18) 0deg,
            rgba(77, 212, 172, 0.15) 120deg,
            rgba(88, 168, 255, 0.18) 240deg,
            rgba(88, 168, 255, 0.18) 360deg
          ),
          rgba(11, 20, 33, 0.92);
        box-shadow: 0 6px 24px rgba(88, 168, 255, 0.4);
        animation: shimmer 3s ease-in-out infinite;
      }

      .phase.active::before {
        background: var(--accent);
        box-shadow: 0 0 0 3px rgba(77, 212, 172, 0.6);
        animation: pulse-glow 2s ease-in-out infinite;
      }

      .phase strong {
        display: block;
        font-size: 0.82rem;
        margin-bottom: 0.35rem;
        color: #e8f2ff;
        font-weight: 600;
      }

      .phase span {
        color: var(--muted);
        font-size: 0.73rem;
        line-height: 1.45;
      }

      .foot {
        text-align: center;
        color: #b5c8e5;
        font-size: 0.74rem;
        padding: 0.4rem;
        line-height: 1.6;
      }

      .mono {
        font-family: "IBM Plex Mono", ui-monospace, SFMono-Regular, Menlo, monospace;
      }

      .hidden {
        display: none;
      }

      .approval-modal {
        position: fixed;
        left: 50%;
        top: 50%;
        transform: translate(-50%, -50%);
        background:
          radial-gradient(circle at 30% 40%, rgba(88, 168, 255, 0.15) 0%, transparent 70%),
          rgba(20, 30, 45, 0.98);
        border: 2px solid rgba(255, 187, 85, 0.6);
        border-radius: 16px;
        padding: 1.5rem;
        min-width: 380px;
        box-shadow: 0 24px 60px rgba(4, 8, 15, 0.7);
        z-index: 1000;
        animation: slideIn 300ms ease-out;
      }

      @keyframes slideIn {
        from {
          opacity: 0;
          transform: translate(-50%, -60%);
        }
        to {
          opacity: 1;
          transform: translate(-50%, -50%);
        }
      }

      .approval-modal h3 {
        margin: 0 0 0.5rem;
        font-size: 1.1rem;
        color: #ffe0a8;
        font-weight: 700;
      }

      .approval-modal p {
        margin: 0 0 1.2rem;
        color: #d0ddf3;
        font-size: 0.88rem;
        line-height: 1.5;
      }

      .approval-actions {
        display: flex;
        gap: 0.8rem;
        justify-content: flex-end;
      }

      .approval-btn {
        border: 1px solid var(--border);
        border-radius: 10px;
        font: inherit;
        font-size: 0.85rem;
        font-weight: 600;
        padding: 0.6rem 1.2rem;
        cursor: pointer;
        transition: all 160ms ease;
      }

      .approval-btn.approve {
        background: linear-gradient(135deg, rgba(77, 212, 172, 0.9), rgba(97, 228, 165, 0.9));
        color: #0e1118;
        border-color: rgba(77, 212, 172, 0.8);
      }

      .approval-btn.approve:hover {
        background: linear-gradient(135deg, rgba(77, 212, 172, 1), rgba(97, 228, 165, 1));
        transform: translateY(-1px);
        box-shadow: 0 4px 16px rgba(77, 212, 172, 0.4);
      }

      .approval-btn.deny {
        background: linear-gradient(135deg, rgba(255, 111, 125, 0.9), rgba(255, 140, 150, 0.9));
        color: #0e1118;
        border-color: rgba(255, 111, 125, 0.8);
      }

      .approval-btn.deny:hover {
        background: linear-gradient(135deg, rgba(255, 111, 125, 1), rgba(255, 140, 150, 1));
        transform: translateY(-1px);
        box-shadow: 0 4px 16px rgba(255, 111, 125, 0.4);
      }

      .flow-row.pending::before {
        background: var(--accent-3);
        box-shadow: 0 0 12px rgba(255, 187, 85, 0.8);
        animation: pulse-pending 1s ease-in-out infinite;
      }

      @keyframes pulse-pending {
        0%,
        100% {
          transform: scale(1);
          opacity: 1;
        }
        50% {
          transform: scale(1.2);
          opacity: 0.7;
        }
      }

      .flow-row.denied::before {
        background: var(--danger);
        box-shadow: 0 0 12px rgba(255, 111, 125, 0.8);
        animation: none;
      }

      .flow-row.approved::before {
        background: var(--accent);
        box-shadow: 0 0 12px rgba(77, 212, 172, 0.8);
      }

      .learning-indicator {
        position: fixed;
        right: 2rem;
        bottom: 2rem;
        background:
          radial-gradient(circle at 30% 40%, rgba(176, 139, 255, 0.15) 0%, transparent 70%),
          rgba(20, 30, 45, 0.95);
        border: 1px solid rgba(176, 139, 255, 0.6);
        border-radius: 12px;
        padding: 1rem 1.2rem;
        min-width: 280px;
        box-shadow: 0 8px 24px rgba(176, 139, 255, 0.3);
        z-index: 999;
        animation: fadeInUp 400ms ease-out;
      }

      @keyframes fadeInUp {
        from {
          opacity: 0;
          transform: translateY(20px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }

      .learning-indicator h4 {
        margin: 0 0 0.4rem;
        font-size: 0.9rem;
        color: #d0b8ff;
        font-weight: 700;
        display: flex;
        align-items: center;
        gap: 0.5rem;
      }

      .learning-indicator p {
        margin: 0;
        color: #b5c8e5;
        font-size: 0.78rem;
        line-height: 1.5;
      }

      .learning-spinner {
        display: inline-block;
        width: 0.8rem;
        height: 0.8rem;
        border: 2px solid rgba(176, 139, 255, 0.3);
        border-top-color: #d0b8ff;
        border-radius: 50%;
        animation: spin 800ms linear infinite;
      }

      @keyframes spin {
        to {
          transform: rotate(360deg);
        }
      }

      @media (max-width: 1180px) {
        .grid {
          grid-template-columns: 1fr;
        }

        .detail-scroll {
          max-height: 460px;
        }

        #systemGraph {
          height: 520px;
        }

        .data-card-grid {
          grid-template-columns: 1fr;
        }

        .timeline {
          flex-direction: column;
          padding-top: 0;
          padding-left: 1rem;
        }

        .timeline::before {
          left: 0.35rem;
          right: auto;
          top: 1.5rem;
          bottom: 1.5rem;
          width: 3px;
          height: auto;
          background: linear-gradient(
            180deg,
            rgba(77, 212, 172, 0.85) 0%,
            rgba(88, 168, 255, 0.65) 50%,
            rgba(255, 187, 85, 0.65) 100%
          );
        }

        .phase {
          padding-left: 2.2rem;
        }

        .phase::before {
          left: 0.35rem;
          top: calc(50% - 0.35rem);
        }
      }

      @media (max-width: 860px) {
        .stats {
          grid-template-columns: repeat(2, minmax(0, 1fr));
        }

        .risk-row {
          grid-template-columns: 56px 1fr;
          grid-template-areas:
            "tag main"
            "action action";
        }

        .risk-tag {
          grid-area: tag;
        }

        .risk-main {
          grid-area: main;
        }

        .risk-action {
          grid-area: action;
          text-align: left;
        }

        #systemGraph {
          height: 430px;
        }
      }
    </style>
  </head>
  <body>
    <div class="wrap">
      <header class="hero panel">
        <div class="hero-top">
          <span class="badge">Adaptive Tool Approval • Interactive Overview</span>
          <span class="badge mono">Select nodes • Drill down • Focus mode</span>
        </div>
        <h1>OpenClaw Architecture: Approval When It Matters</h1>
        <p>
          This one-page map consolidates the architecture and implementation vision for dynamic tool
          approval gating. It combines hard policy controls with classifier-assisted risk
          evaluation, then routes approval requests through channel-native operator surfaces. Click
          any element to inspect responsibilities, interfaces, risk handling, rollout phase, and
          test strategy.
        </p>
        <section class="stats">
          <article class="stat">
            <strong>20</strong>
            <span>Core architecture elements</span>
          </article>
          <article class="stat">
            <strong>5</strong>
            <span>Risk classes (R0 → R4)</span>
          </article>
          <article class="stat">
            <strong>5</strong>
            <span>Rollout phases</span>
          </article>
          <article class="stat">
            <strong>3</strong>
            <span>Routing modes (session/targets/both)</span>
          </article>
          <article class="stat">
            <strong>&lt;1.2s</strong>
            <span>Classifier timeout budget target</span>
          </article>
        </section>
      </header>

      <section class="toolbar panel">
        <div class="toolbar-row">
          <label class="search-wrap" for="search">
            <input
              id="search"
              type="search"
              placeholder="Find by component, API, phase, risk, or behavior..."
            />
            <span class="search-hint">/</span>
          </label>
          <button id="clearSearch" class="ghost" type="button">Clear</button>
          <button id="downloadSnapshot" class="ghost" type="button">Download Snapshot JSON</button>
          <button id="toggleFocus" class="ghost" type="button">Focus: Off</button>
        </div>
        <div class="toolbar-row">
          <strong style="font-size: 0.8rem; color: #e0edff; font-weight: 600">Lens:</strong>
          <div class="pill-row" id="lensRow" role="tablist" aria-label="Architecture lens">
            <button class="pill active" type="button" data-lens="all">All</button>
            <button class="pill" type="button" data-lens="runtime">Runtime</button>
            <button class="pill" type="button" data-lens="decision">Decisioning</button>
            <button class="pill" type="button" data-lens="gateway">Gateway</button>
            <button class="pill" type="button" data-lens="channels">Channels</button>
            <button class="pill" type="button" data-lens="ops">Audit & Ops</button>
          </div>
        </div>
      </section>

      <main class="grid">
        <section class="panel graph-shell">
          <div class="graph-head">
            <h2 class="graph-title">System Relationship Graph</h2>
            <div class="graph-actions">
              <button id="playFlow" class="ghost" type="button">Play Invocation Path</button>
              <button id="resetGraph" class="ghost" type="button">Reset View</button>
            </div>
          </div>
          <div class="graph-wrap">
            <svg
              id="systemGraph"
              viewBox="0 0 1180 560"
              role="img"
              aria-label="Architecture relationship graph"
            ></svg>
          </div>
          <div class="legend">
            <span class="legend-item"
              ><i class="dot" style="background: #4dd4ac"></i>Runtime & Policy</span
            >
            <span class="legend-item"
              ><i class="dot" style="background: #58a8ff"></i>Gateway & Approval Core</span
            >
            <span class="legend-item"
              ><i class="dot" style="background: #ffbb55"></i>Channels & Operator Surfaces</span
            >
            <span class="legend-item"
              ><i class="dot" style="background: #b08bff"></i>Audit, Metrics, Rollout</span
            >
          </div>
        </section>

        <aside class="panel detail">
          <div>
            <h2 id="detailTitle">Select an architectural element</h2>
            <div id="detailSub" class="detail-sub">
              Click a graph node, flow step, risk tier, or rollout phase.
            </div>
          </div>
          <div id="detailChips" class="detail-chips"></div>
          <div class="detail-scroll">
            <div id="detailBody"></div>
          </div>
        </aside>
      </main>

      <section class="data-card-grid">
        <article class="panel subpanel">
          <h3>Approval Workflow & Decision Path</h3>
          <p style="color: var(--muted); font-size: 0.82rem; margin: 0 0 0.6rem; line-height: 1.5">
            Each step clearly shows its approval mechanism:
          </p>
          <div style="display: flex; gap: 0.5rem; flex-wrap: wrap; margin-bottom: 1rem">
            <span class="mechanism-badge rules">
              <span class="mechanism-icon"></span>
              Rules-Based
            </span>
            <span class="mechanism-badge llm">
              <span class="mechanism-icon"></span>
              LLM-Based
            </span>
            <span class="mechanism-badge human">
              <span class="mechanism-icon"></span>
              Human-Based
            </span>
            <span class="mechanism-badge hybrid">
              <span class="mechanism-icon"></span>
              Hybrid
            </span>
          </div>
          <div id="flowGrid" class="flow-grid"></div>
        </article>

        <article class="panel subpanel">
          <h3>Risk Taxonomy</h3>
          <div id="riskTable" class="risk-table"></div>
        </article>
      </section>

      <article class="panel subpanel full-width-card">
        <h3>Rollout Roadmap</h3>
        <p style="color: var(--muted); font-size: 0.82rem; margin: 0 0 1rem; line-height: 1.5">
          Five-phase incremental rollout from foundations to full generic tool approval. Each phase
          builds on the previous with parity checks and stability windows.
        </p>
        <div id="timeline" class="timeline"></div>
      </article>

      <footer class="foot">
        Source design docs:
        <span class="mono">docs/refactor/adaptive-tool-approval-architecture.md</span>
        and
        <span class="mono">docs/refactor/adaptive-tool-approval-implementation.md</span>
      </footer>
    </div>

    <script>
      const NODES = [
        {
          id: "entry",
          label: "Tool Invocation Entry",
          layer: "runtime",
          group: "runtime",
          x: 86,
          y: 94,
          summary: "Every tool call enters through a shared orchestration seam.",
          detail: {
            why: "Centralizing entry ensures one consistent approval experience regardless of tool type.",
            responsibilities: [
              "Normalize invocation context (tool, params, agent, session, channel)",
              "Pass invocation through policy and safety pipeline",
              "Attach consistent trace metadata",
            ],
            interfaces: ["src/agents/pi-tools.ts", "src/agents/pi-tools.before-tool-call.ts"],
            tests: [
              "Invocation parity tests",
              "Non-regression against existing tool execution behavior",
            ],
          },
          tags: ["Runtime", "Entry", "Shared Path"],
        },
        {
          id: "policy",
          label: "Hard Tool Policy Gate",
          layer: "runtime",
          group: "runtime",
          x: 278,
          y: 94,
          summary:
            "Existing allow/deny and sandbox constraints run first and remain authoritative.",
          detail: {
            why: "Model judgement must never override deterministic enforcement.",
            responsibilities: [
              "Apply global + agent + session + channel policy",
              "Evaluate sandbox-aware tool constraints",
              "Stop execution immediately on deny",
            ],
            interfaces: ["src/agents/pi-tools.policy.ts", "src/agents/tool-policy.ts"],
            tests: ["Deny precedence tests", "Provider policy tests", "Group policy tests"],
          },
          tags: ["Runtime", "Policy", "Deterministic"],
        },
        {
          id: "orchestrator",
          label: "Approval Orchestrator",
          layer: "decision",
          group: "runtime",
          x: 468,
          y: 94,
          summary: "Shared decision controller for allow, deny, or approval-required outcomes.",
          detail: {
            why: "Keeps behavior uniform across tools and channels.",
            responsibilities: [
              "Call static evaluator and optional classifier",
              "Apply policy thresholds",
              "Open approval request lifecycle when required",
            ],
            interfaces: ["src/approvals/tool-approval-orchestrator.ts"],
            tests: [
              "Decision path coverage",
              "Timeout and retry behavior",
              "Feature-flag off no-op parity",
            ],
          },
          tags: ["Decision", "Core"],
        },
        {
          id: "static-eval",
          label: "Static Risk Evaluator",
          layer: "decision",
          group: "runtime",
          x: 662,
          y: 50,
          summary:
            "Low-latency deterministic classifier based on tool semantics and side-effect signatures.",
          detail: {
            why: "Most calls should be decided without model latency.",
            responsibilities: [
              "Map tool call to risk class R0-R4",
              "Extract side-effect hints and reason codes",
              "Flag uncertain cases for optional fast-model classification",
            ],
            interfaces: ["src/approvals/tool-risk-static.ts", "src/approvals/risk-taxonomy.ts"],
            tests: [
              "Golden matrix tests by tool and param shape",
              "Regression tests for risk class thresholds",
            ],
          },
          tags: ["Decision", "Static", "Latency-Critical"],
        },
        {
          id: "fast-classifier",
          label: "Fast Safety Classifier",
          layer: "decision",
          group: "runtime",
          x: 662,
          y: 138,
          summary:
            "Optional micro-model inference for ambiguous calls with strict timeout and confidence policy.",
          detail: {
            why: "Improves adaptiveness while keeping decision authority in policy engine.",
            responsibilities: [
              "Process compact context package (no chain of thought)",
              "Return structured risk + confidence",
              "Fallback cleanly on timeout or low confidence",
            ],
            interfaces: ["src/approvals/tool-risk-classifier.ts"],
            tests: [
              "Timeout fallback tests",
              "Malformed response handling",
              "Confidence threshold decisions",
            ],
          },
          tags: ["Decision", "Model-Assisted", "Optional"],
        },
        {
          id: "decision-engine",
          label: "Decision Engine",
          layer: "decision",
          group: "runtime",
          x: 860,
          y: 94,
          summary:
            "Converts assessment into allow, deny, or approval required according to policy.",
          detail: {
            why: "Separates model output from enforceable policy.",
            responsibilities: [
              "Apply risk policy and side-effect rules",
              "Enforce deny-by-default rules for critical ambiguity",
              "Emit machine-readable decision rationale",
            ],
            interfaces: ["src/approvals/tool-decision-engine.ts"],
            tests: [
              "Policy matrix tests",
              "R3/R4 explicit gating tests",
              "Low-confidence fallback tests",
            ],
          },
          tags: ["Decision", "Policy", "Risk"],
        },
        {
          id: "execute",
          label: "Tool Execution",
          layer: "runtime",
          group: "runtime",
          x: 1064,
          y: 62,
          summary: "Tool execution only occurs after decision path resolves to allow.",
          detail: {
            why: "Execution path should be transparent, auditable, and unchanged for safe calls.",
            responsibilities: [
              "Run tool with normalized context",
              "Return deterministic blocked result when denied",
              "Propagate structured events for observability",
            ],
            interfaces: ["Existing tool implementations in src/agents/*"],
            tests: ["No-regression tool result tests", "Approval-approved continuation tests"],
          },
          tags: ["Runtime", "Execution"],
        },
        {
          id: "approval-request",
          label: "tool.approval.request API",
          layer: "gateway",
          group: "gateway",
          x: 1064,
          y: 150,
          summary: "Gateway API entrypoint for opening pending approval records.",
          detail: {
            why: "Unified API supports all tool types and all approver surfaces.",
            responsibilities: [
              "Create immutable approval records with TTL",
              "Broadcast approval.requested event",
              "Expose compatibility aliases for legacy exec flow",
            ],
            interfaces: [
              "src/gateway/server-methods/tool-approval.ts",
              "src/gateway/protocol/schema/tool-approvals.ts",
            ],
            tests: ["Duplicate ID rejection", "Schema validation tests", "Scope enforcement tests"],
          },
          tags: ["Gateway", "API", "Approval Lifecycle"],
        },
        {
          id: "approval-manager",
          label: "Approval Manager",
          layer: "gateway",
          group: "gateway",
          x: 858,
          y: 226,
          summary: "Pending approval state, idempotency, expiry, and resolution ownership.",
          detail: {
            why: "Single source of truth for active approvals.",
            responsibilities: [
              "Track pending entries and expiry timers",
              "Resolve decisions exactly once",
              "Publish lifecycle events",
            ],
            interfaces: ["src/gateway/tool-approval-manager.ts"],
            tests: [
              "Timeout expiry tests",
              "Single-resolution guarantees",
              "Concurrent resolver tests",
            ],
          },
          tags: ["Gateway", "State", "Reliability"],
        },
        {
          id: "router",
          label: "Approval Router",
          layer: "gateway",
          group: "gateway",
          x: 660,
          y: 226,
          summary:
            "Routes approval prompts across session-origin channels and explicit operator targets.",
          detail: {
            why: "Users should approve where they already are, not only in one UI.",
            responsibilities: [
              "Resolve routing mode (session, targets, both)",
              "Deduplicate deliveries and isolate adapter failures",
              "Track resolution fanout state",
            ],
            interfaces: ["src/infra/tool-approval-forwarder.ts"],
            tests: ["Routing mode tests", "Target dedup tests", "Partial delivery failure tests"],
          },
          tags: ["Gateway", "Routing", "Channels"],
        },
        {
          id: "control-ui",
          label: "Control UI Adapter",
          layer: "channels",
          group: "channels",
          x: 456,
          y: 226,
          summary: "Primary operator interface for rich approval inspection and action.",
          detail: {
            why: "Best surface for high-context approvals with low friction.",
            responsibilities: [
              "Render approval cards with risk rationale",
              "Send tool.approval.resolve decisions",
              "Show pending/expired/resolved transitions",
            ],
            interfaces: ["Gateway WS event stream", "operator.approvals scope"],
            tests: ["UI action binding tests", "Event ordering tests"],
          },
          tags: ["Channels", "UI", "Operator"],
        },
        {
          id: "cli-operator",
          label: "CLI Operator Adapter",
          layer: "channels",
          group: "channels",
          x: 276,
          y: 226,
          summary:
            "Terminal-native approval surface for scriptable operations and remote sessions.",
          detail: {
            why: "Ensures headless operations still support safe approvals.",
            responsibilities: [
              "Display approval prompts and IDs",
              "Allow allow-once / allow-always / deny actions",
              "Integrate with gateway auth/scopes",
            ],
            interfaces: ["openclaw approvals ...", "operator.approvals scope"],
            tests: ["CLI command integration tests", "Auth/scope tests"],
          },
          tags: ["Channels", "CLI", "Operator"],
        },
        {
          id: "chat-adapters",
          label: "Chat Channel Adapters",
          layer: "channels",
          group: "channels",
          x: 84,
          y: 226,
          summary:
            "Approvals delivered to channels like Discord/Slack/Telegram and extension connectors.",
          detail: {
            why: "Approval should meet users in their active communication surface.",
            responsibilities: [
              "Render interactive or command-based approvals",
              "Bind responses to tool.approval.resolve",
              "Respect channel-level filters and account routing",
            ],
            interfaces: [
              "src/discord/monitor/exec-approvals.ts (existing pattern)",
              "Outbound delivery adapters",
            ],
            tests: ["Adapter contract tests", "Rate limit/timeout behavior tests"],
          },
          tags: ["Channels", "Messaging", "Plugins"],
        },
        {
          id: "resolve-api",
          label: "tool.approval.resolve API",
          layer: "gateway",
          group: "gateway",
          x: 468,
          y: 304,
          summary: "Resolution API for all approver surfaces under operator.approvals scope.",
          detail: {
            why: "Unified resolution path prevents divergent semantics across channels.",
            responsibilities: [
              "Validate decision payloads",
              "Record resolver identity and source surface",
              "Emit resolved event and unblock orchestrator waiters",
            ],
            interfaces: ["src/gateway/server-methods/tool-approval.ts"],
            tests: ["Unknown ID handling", "Scope enforcement", "Decision schema validation"],
          },
          tags: ["Gateway", "API", "Resolution"],
        },
        {
          id: "audit",
          label: "Audit Trail",
          layer: "ops",
          group: "ops",
          x: 660,
          y: 394,
          summary: "Immutable records for approvals, decisions, resolver identity, and outcomes.",
          detail: {
            why: "Required for trust, incident analysis, and governance.",
            responsibilities: [
              "Persist request/resolve metadata",
              "Store rationale and reason codes",
              "Correlate with execution result state",
            ],
            interfaces: ["Structured event logs", "Gateway audit sink"],
            tests: ["Log completeness checks", "PII/sensitive field redaction tests"],
          },
          tags: ["Ops", "Audit", "Security"],
        },
        {
          id: "metrics",
          label: "Metrics & SLOs",
          layer: "ops",
          group: "ops",
          x: 860,
          y: 394,
          summary: "Runtime and approval quality telemetry to tune friction vs risk.",
          detail: {
            why: "Adaptive systems need measurable quality loops.",
            responsibilities: [
              "Track approval volume and outcomes by risk class/tool/channel",
              "Measure classifier latency and fallback rate",
              "Expose SLO health and anomaly signals",
            ],
            interfaces: ["tool_approval_requests_total", "tool_safety_classifier_latency_ms"],
            tests: ["Metric emission tests", "Label cardinality guard tests"],
          },
          tags: ["Ops", "Metrics", "SLO"],
        },
        {
          id: "risk-policy",
          label: "Risk Policy Config",
          layer: "decision",
          group: "runtime",
          x: 1064,
          y: 304,
          summary: "Configurable policy thresholds controlling approval/deny behavior.",
          detail: {
            why: "Teams need explicit governance knobs without code changes.",
            responsibilities: [
              "Define approval threshold (e.g., R3+)",
              "Define deny threshold (e.g., R4+)",
              "Set low-confidence fallback behavior",
            ],
            interfaces: ["approvals.tools.policy.*", "approvals.tools.classifier.*"],
            tests: ["Config validation tests", "Threshold decision tests"],
          },
          tags: ["Decision", "Config", "Governance"],
        },
        {
          id: "compat",
          label: "Exec Compatibility Bridge",
          layer: "gateway",
          group: "gateway",
          x: 276,
          y: 394,
          summary:
            "Legacy exec.approval APIs continue while migration shifts to generic tool approval.",
          detail: {
            why: "Avoid breaking stable exec approval workflows during rollout.",
            responsibilities: [
              "Map exec.approval.* to tool.approval.* internals",
              "Preserve allow-once/always semantics",
              "Run parity assertions during migration window",
            ],
            interfaces: ["src/gateway/server-methods/exec-approval.ts"],
            tests: ["Backcompat integration tests", "Exec parity regression tests"],
          },
          tags: ["Gateway", "Migration", "Backcompat"],
        },
        {
          id: "rollout",
          label: "Phased Rollout Controller",
          layer: "ops",
          group: "ops",
          x: 84,
          y: 394,
          summary: "Feature-flagged rollout from foundations to full generic tool approval.",
          detail: {
            why: "Incremental rollout lowers risk and preserves service reliability.",
            responsibilities: [
              "Enable by phase and environment",
              "Collect parity and performance evidence before expansion",
              "Drive deprecation windows",
            ],
            interfaces: ["approvals.tools.enabled", "Phase flags and migration checks"],
            tests: ["Flag gating tests", "Phase-specific regression bundles"],
          },
          tags: ["Ops", "Rollout", "Change Management"],
        },
        {
          id: "docs",
          label: "Architecture Docs",
          layer: "ops",
          group: "ops",
          x: 468,
          y: 394,
          summary: "Design source of truth for architecture decisions and implementation details.",
          detail: {
            why: "Ensures contributors align with one shared implementation plan.",
            responsibilities: [
              "Capture architecture and implementation contracts",
              "Document risk model and migration strategy",
              "Provide onboarding map for future contributors",
            ],
            interfaces: [
              "docs/refactor/adaptive-tool-approval-architecture.md",
              "docs/refactor/adaptive-tool-approval-implementation.md",
            ],
            tests: ["Doc reference consistency checks"],
          },
          tags: ["Docs", "Source of Truth"],
        },
      ];

      const EDGES = [
        ["entry", "policy"],
        ["policy", "orchestrator"],
        ["orchestrator", "static-eval"],
        ["orchestrator", "fast-classifier"],
        ["static-eval", "decision-engine"],
        ["fast-classifier", "decision-engine"],
        ["decision-engine", "execute"],
        ["decision-engine", "approval-request"],
        ["approval-request", "approval-manager"],
        ["approval-manager", "router"],
        ["router", "control-ui"],
        ["router", "cli-operator"],
        ["router", "chat-adapters"],
        ["control-ui", "resolve-api"],
        ["cli-operator", "resolve-api"],
        ["chat-adapters", "resolve-api"],
        ["resolve-api", "approval-manager"],
        ["approval-manager", "orchestrator"],
        ["execute", "audit"],
        ["approval-manager", "audit"],
        ["audit", "metrics"],
        ["risk-policy", "decision-engine"],
        ["compat", "approval-manager"],
        ["rollout", "compat"],
        ["rollout", "orchestrator"],
        ["docs", "rollout"],
      ];

      const FLOW_STEPS = [
        {
          id: "f1",
          title: "Invoke",
          hint: "Tool call enters shared path",
          node: "entry",
          mechanism: "rules",
          mechanismLabel: "Rules-Based",
        },
        {
          id: "f2",
          title: "Hard Policy",
          hint: "Allow/deny + sandbox constraints",
          node: "policy",
          mechanism: "rules",
          mechanismLabel: "Rules-Based",
        },
        {
          id: "f3",
          title: "Static Risk",
          hint: "Deterministic assessment by tool semantics",
          node: "static-eval",
          mechanism: "rules",
          mechanismLabel: "Rules-Based",
        },
        {
          id: "f4",
          title: "Fast Model",
          hint: "LLM classification for ambiguous cases (optional)",
          node: "fast-classifier",
          mechanism: "llm",
          mechanismLabel: "LLM-Based",
        },
        {
          id: "f5",
          title: "Decision",
          hint: "Policy engine evaluates risk + classifier output",
          node: "decision-engine",
          mechanism: "hybrid",
          mechanismLabel: "Hybrid",
        },
        {
          id: "f6",
          title: "Approve",
          hint: "Human operator approval via channels",
          node: "approval-manager",
          mechanism: "human",
          mechanismLabel: "Human-Based",
        },
        {
          id: "f7",
          title: "Execute",
          hint: "Tool execution + audit + metrics",
          node: "execute",
          mechanism: "rules",
          mechanismLabel: "Rules-Based",
        },
      ];

      const FLOW_RESOURCES = {
        f1: [],
        f2: ["Policy Engine", "Sandbox Rules"],
        f3: ["Risk Taxonomy", "Tool Registry"],
        f4: ["Fast Classifier API"],
        f5: ["Decision Engine", "Policy Config"],
        f6: ["Approval Manager", "Channel Router", "Control UI", "CLI", "Chat Adapters"],
        f7: ["Audit Trail", "Metrics Collector"],
      };

      const RISKS = [
        {
          id: "R0",
          className: "r0",
          title: "Read-only internal",
          examples: "read, sessions history, metadata lookup",
          action: "Allow",
          details:
            "No external mutation. Should remain frictionless unless explicit policy override exists.",
        },
        {
          id: "R1",
          className: "r1",
          title: "Local workspace mutation",
          examples: "write, edit, apply_patch in approved workspace",
          action: "Allow (policy-bound)",
          details:
            "Constrained by hard policy and sandbox access. Usually no human approval needed.",
        },
        {
          id: "R2",
          className: "r2",
          title: "External read or low-impact action",
          examples: "web search/fetch, status reads",
          action: "Allow or conditional approval",
          details:
            "Use fast classifier only for ambiguous requests with potential hidden side effects.",
        },
        {
          id: "R3",
          className: "r3",
          title: "External mutation",
          examples: "message send, gateway write, cron change",
          action: "Approval Required",
          details:
            "Default threshold for adaptive approval. Requires explicit resolution by an operator surface.",
        },
        {
          id: "R4",
          className: "r4",
          title: "High-impact / dangerous",
          examples: "destructive system change, security boundary modification",
          action: "Deny or break-glass approval",
          details:
            "Default deny for ambiguity. Tightest controls, strict audit, highest signal-to-noise requirements.",
        },
      ];

      const PHASES = [
        {
          id: "P1",
          title: "Phase 1 — Foundations",
          short: "Risk taxonomy, orchestrator shell, feature flags",
          highlights: [
            "Introduce static evaluator and decision contracts",
            "No behavior change when feature disabled",
            "Build baseline unit and parity tests",
          ],
        },
        {
          id: "P2",
          title: "Phase 2 — Gateway Generic Approvals",
          short: "tool.approval APIs/events + manager",
          highlights: [
            "Add generic gateway methods and schemas",
            "Keep exec APIs as compatibility aliases",
            "Scope enforcement under operator.approvals",
          ],
        },
        {
          id: "P3",
          title: "Phase 3 — Routing & Channels",
          short: "Session/target/both routing adapters",
          highlights: [
            "Add generalized approval forwarder",
            "Fanout to control UI, CLI, and chat adapters",
            "Dedup and partial failure resilience",
          ],
        },
        {
          id: "P4",
          title: "Phase 4 — Fast Classifier",
          short: "Low-latency contextual risk assist",
          highlights: [
            "Add classifier client with strict timeout",
            "Confidence thresholds and deterministic fallback",
            "Track latency and fallback metrics",
          ],
        },
        {
          id: "P5",
          title: "Phase 5 — Exec Migration",
          short: "Move exec to shared orchestration path",
          highlights: [
            "Preserve allow-once/allow-always semantics",
            "Dual-path parity checks before default switch",
            "Deprecate legacy internals after compatibility window",
          ],
        },
      ];

      const GROUP_STYLES = {
        runtime: { fill: "#4dd4ac", glow: "rgba(77,212,172,0.42)" },
        gateway: { fill: "#58a8ff", glow: "rgba(88,168,255,0.42)" },
        channels: { fill: "#ffbb55", glow: "rgba(255,187,85,0.42)" },
        ops: { fill: "#b08bff", glow: "rgba(176,139,255,0.42)" },
      };

      const state = {
        selectedId: null,
        selectedFlow: null,
        selectedRisk: null,
        selectedPhase: null,
        lens: "all",
        search: "",
        focus: false,
        playing: false,
        approvalPending: false,
        approvalDecision: null,
        learningActive: false,
      };

      const nodeMap = new Map(NODES.map((node) => [node.id, node]));
      const adjacency = new Map();
      for (const [a, b] of EDGES) {
        if (!adjacency.has(a)) adjacency.set(a, new Set());
        if (!adjacency.has(b)) adjacency.set(b, new Set());
        adjacency.get(a).add(b);
        adjacency.get(b).add(a);
      }

      const graphSvg = document.getElementById("systemGraph");
      const detailTitle = document.getElementById("detailTitle");
      const detailSub = document.getElementById("detailSub");
      const detailChips = document.getElementById("detailChips");
      const detailBody = document.getElementById("detailBody");
      const flowGrid = document.getElementById("flowGrid");
      const riskTable = document.getElementById("riskTable");
      const timeline = document.getElementById("timeline");
      const searchInput = document.getElementById("search");
      const clearSearchButton = document.getElementById("clearSearch");
      const downloadSnapshotButton = document.getElementById("downloadSnapshot");
      const toggleFocusButton = document.getElementById("toggleFocus");
      const resetGraphButton = document.getElementById("resetGraph");
      const playFlowButton = document.getElementById("playFlow");

      function createSvgElement(name, attrs = {}) {
        const el = document.createElementNS("http://www.w3.org/2000/svg", name);
        for (const [key, value] of Object.entries(attrs)) {
          el.setAttribute(key, String(value));
        }
        return el;
      }

      function matchesLens(node) {
        if (state.lens === "all") return true;
        if (state.lens === "runtime") return node.group === "runtime";
        if (state.lens === "gateway") return node.group === "gateway";
        if (state.lens === "channels") return node.group === "channels";
        if (state.lens === "ops") return node.group === "ops";
        if (state.lens === "decision") {
          return node.layer === "decision";
        }
        return true;
      }

      function matchesSearch(node) {
        if (!state.search) return true;
        const haystack = [
          node.label,
          node.summary,
          ...(node.tags || []),
          ...(node.detail.interfaces || []),
          ...(node.detail.responsibilities || []),
        ]
          .join(" ")
          .toLowerCase();
        return haystack.includes(state.search.toLowerCase());
      }

      function isFocusedVisible(nodeId) {
        if (!state.focus || !state.selectedId) return true;
        if (nodeId === state.selectedId) return true;
        return adjacency.get(state.selectedId)?.has(nodeId) || false;
      }

      function nodeOpacity(node) {
        const visible = matchesLens(node) && matchesSearch(node) && isFocusedVisible(node.id);
        return visible ? 1 : 0.14;
      }

      function edgeOpacity(from, to) {
        const fromNode = nodeMap.get(from);
        const toNode = nodeMap.get(to);
        if (!fromNode || !toNode) return 0.08;
        const visible =
          matchesLens(fromNode) &&
          matchesLens(toNode) &&
          matchesSearch(fromNode) &&
          matchesSearch(toNode) &&
          isFocusedVisible(from) &&
          isFocusedVisible(to);
        if (!visible) return 0.06;
        if (!state.selectedId) return 0.32;
        return from === state.selectedId || to === state.selectedId ? 0.86 : 0.18;
      }

      function renderGraph() {
        graphSvg.innerHTML = "";

        const defs = createSvgElement("defs");
        const marker = createSvgElement("marker", {
          id: "arrow",
          viewBox: "0 0 10 10",
          refX: "8",
          refY: "5",
          markerWidth: "7",
          markerHeight: "7",
          orient: "auto-start-reverse",
        });
        marker.appendChild(
          createSvgElement("path", {
            d: "M 0 0 L 10 5 L 0 10 z",
            fill: "rgba(190,209,239,0.6)",
          }),
        );
        defs.appendChild(marker);
        graphSvg.appendChild(defs);

        for (const [from, to] of EDGES) {
          const a = nodeMap.get(from);
          const b = nodeMap.get(to);
          if (!a || !b) continue;
          const line = createSvgElement("line", {
            x1: a.x,
            y1: a.y,
            x2: b.x,
            y2: b.y,
            stroke: "rgba(196,214,242,0.68)",
            "stroke-width": from === state.selectedId || to === state.selectedId ? "3" : "2",
            "stroke-linecap": "round",
            "marker-end": "url(#arrow)",
            opacity: edgeOpacity(from, to),
          });
          graphSvg.appendChild(line);
        }

        for (const node of NODES) {
          const style = GROUP_STYLES[node.group];
          const isActive = node.id === state.selectedId;
          const opacity = nodeOpacity(node);

          const g = createSvgElement("g", {
            transform: `translate(${node.x},${node.y})`,
            opacity,
            role: "button",
            tabindex: "0",
            "aria-label": node.label,
          });

          if (isActive) {
            const outerGlow = createSvgElement("circle", {
              cx: "0",
              cy: "0",
              r: "48",
              fill: style.glow,
              opacity: "0.5",
            });
            g.appendChild(outerGlow);
          }

          const shadow = createSvgElement("circle", {
            cx: "0",
            cy: "0",
            r: isActive ? "42" : "36",
            fill: style.glow,
          });
          g.appendChild(shadow);

          const ring = createSvgElement("circle", {
            cx: "0",
            cy: "0",
            r: isActive ? "29.5" : "26.5",
            fill: "#102035",
            stroke: isActive ? style.fill : "rgba(255,255,255,0.33)",
            "stroke-width": isActive ? "3.2" : "1.6",
          });
          g.appendChild(ring);

          const core = createSvgElement("circle", {
            cx: "0",
            cy: "0",
            r: "14",
            fill: style.fill,
            opacity: isActive ? "1" : "0.86",
          });
          g.appendChild(core);

          const text = createSvgElement("text", {
            x: "0",
            y: "49",
            "text-anchor": "middle",
            fill: "#d9e8ff",
            "font-size": "12",
            "font-weight": isActive ? "700" : "600",
          });
          text.textContent = node.label;
          g.appendChild(text);

          g.addEventListener("click", () => selectNode(node.id));
          g.addEventListener("keydown", (evt) => {
            if (evt.key === "Enter" || evt.key === " ") {
              evt.preventDefault();
              selectNode(node.id);
            }
          });

          graphSvg.appendChild(g);
        }
      }

      function renderDetail(payload) {
        detailTitle.textContent = payload.title;
        detailSub.textContent = payload.subtitle;

        detailChips.innerHTML = "";
        for (const chip of payload.chips || []) {
          const span = document.createElement("span");
          span.className = "chip";
          span.textContent = chip;
          detailChips.appendChild(span);
        }

        detailBody.innerHTML = "";
        for (const block of payload.blocks || []) {
          const wrapper = document.createElement("section");
          wrapper.className = "detail-block";

          const h = document.createElement("h3");
          h.textContent = block.title;
          wrapper.appendChild(h);

          if (Array.isArray(block.list)) {
            const ul = document.createElement("ul");
            for (const item of block.list) {
              const li = document.createElement("li");
              li.textContent = item;
              ul.appendChild(li);
            }
            wrapper.appendChild(ul);
          } else {
            const p = document.createElement("p");
            p.textContent = block.text;
            wrapper.appendChild(p);
          }

          detailBody.appendChild(wrapper);
        }
      }

      function showNodeDetail(nodeId) {
        const node = nodeMap.get(nodeId);
        if (!node) return;
        renderDetail({
          title: node.label,
          subtitle: node.summary,
          chips: node.tags,
          blocks: [
            { title: "Why It Exists", text: node.detail.why },
            { title: "Responsibilities", list: node.detail.responsibilities },
            { title: "Interfaces", list: node.detail.interfaces },
            { title: "Validation & Tests", list: node.detail.tests },
          ],
        });
      }

      function showFlowDetail(stepId) {
        const step = FLOW_STEPS.find((entry) => entry.id === stepId);
        if (!step) return;
        const node = nodeMap.get(step.node);
        renderDetail({
          title: `Flow Step: ${step.title}`,
          subtitle: step.hint,
          chips: ["Invocation Flow", ...(node?.tags || [])],
          blocks: [
            { title: "Step Purpose", text: step.hint },
            {
              title: "Primary Element",
              text: node ? `${node.label} — ${node.summary}` : "Linked node not found.",
            },
            {
              title: "Operational Expectation",
              list: [
                "Must be deterministic and observable",
                "Must preserve deny-by-default for high risk ambiguity",
                "Must not bypass hard tool/sandbox policy",
              ],
            },
          ],
        });
      }

      function showRiskDetail(riskId) {
        const risk = RISKS.find((entry) => entry.id === riskId);
        if (!risk) return;
        renderDetail({
          title: `Risk Class ${risk.id}`,
          subtitle: risk.title,
          chips: ["Risk Taxonomy", `Default: ${risk.action}`],
          blocks: [
            { title: "Scope", text: risk.details },
            { title: "Common Examples", text: risk.examples },
            {
              title: "Policy Guidance",
              list: [
                "Apply hard policy first",
                "Use fast classifier only when static assessment is uncertain",
                "Escalate to approval at configured threshold",
              ],
            },
          ],
        });
      }

      function showPhaseDetail(phaseId) {
        const phase = PHASES.find((entry) => entry.id === phaseId);
        if (!phase) return;
        renderDetail({
          title: phase.title,
          subtitle: phase.short,
          chips: ["Rollout", phase.id],
          blocks: [
            { title: "Phase Goal", text: phase.short },
            { title: "Exit Criteria", list: phase.highlights },
            {
              title: "Rollout Guardrail",
              list: [
                "Do not progress without parity and regression evidence",
                "Keep backcompat path active until stability window closes",
                "Track approval volume and false-positive/false-negative indicators",
              ],
            },
          ],
        });
      }

      function selectNode(nodeId) {
        state.selectedId = nodeId;
        state.selectedFlow = null;
        state.selectedRisk = null;
        state.selectedPhase = null;
        showNodeDetail(nodeId);
        renderGraph();
        updateSelectionStyles();
      }

      function selectFlow(stepId) {
        state.selectedFlow = stepId;
        state.selectedRisk = null;
        state.selectedPhase = null;
        showFlowDetail(stepId);
        const step = FLOW_STEPS.find((entry) => entry.id === stepId);
        if (step) {
          state.selectedId = step.node;
        }
        renderGraph();
        updateSelectionStyles();
      }

      function selectRisk(riskId) {
        state.selectedRisk = riskId;
        state.selectedFlow = null;
        state.selectedPhase = null;
        showRiskDetail(riskId);
        updateSelectionStyles();
      }

      function selectPhase(phaseId) {
        state.selectedPhase = phaseId;
        state.selectedFlow = null;
        state.selectedRisk = null;
        showPhaseDetail(phaseId);
        updateSelectionStyles();
      }

      function updateSelectionStyles() {
        for (const row of flowGrid.querySelectorAll(".flow-row")) {
          const isActive = row.dataset.id === state.selectedFlow;
          row.classList.toggle("active", isActive);
          const btn = row.querySelector(".flow-step");
          if (btn) btn.classList.toggle("active", isActive);
        }
        for (const row of riskTable.querySelectorAll(".risk-row")) {
          row.classList.toggle("active", row.dataset.id === state.selectedRisk);
        }
        for (const row of timeline.querySelectorAll(".phase")) {
          row.classList.toggle("active", row.dataset.id === state.selectedPhase);
        }
      }

      function renderFlow() {
        flowGrid.innerHTML = "";
        for (const step of FLOW_STEPS) {
          const row = document.createElement("div");
          row.className = "flow-row";
          row.dataset.id = step.id;

          const btn = document.createElement("button");
          btn.className = "flow-step";
          btn.type = "button";
          btn.dataset.id = step.id;
          btn.innerHTML = `
            <strong>${step.title}
              <span class="mechanism-badge ${step.mechanism}">
                <span class="mechanism-icon"></span>
                ${step.mechanismLabel}
              </span>
            </strong>
            <span class="flow-step-hint">${step.hint}</span>
          `;
          btn.addEventListener("click", () => selectFlow(step.id));
          row.appendChild(btn);

          const resources = FLOW_RESOURCES[step.id];
          if (resources && resources.length > 0) {
            const connectors = document.createElement("div");
            // Use trunk layout for 3+ items (vertical trunk with horizontal branches)
            connectors.className = "flow-connectors" + (resources.length > 2 ? " has-trunk" : "");
            for (let i = 0; i < resources.length; i++) {
              const r = resources[i];
              const line = document.createElement("div");
              line.className = "flow-connector-line";

              line.innerHTML = `<span class="connector-track"></span><span class="resource-orb">${r}</span>`;
              connectors.appendChild(line);
            }
            row.appendChild(connectors);
          }

          flowGrid.appendChild(row);
        }
      }

      function renderRisks() {
        riskTable.innerHTML = "";

        const actionClassMap = {
          Allow: "action-allow",
          "Allow (policy-bound)": "action-allow-policy",
          "Allow or conditional approval": "action-conditional",
          "Approval Required": "action-approval",
          "Deny or break-glass approval": "action-deny",
        };

        for (const risk of RISKS) {
          const row = document.createElement("button");
          row.type = "button";
          row.className = "risk-row";
          row.dataset.id = risk.id;

          const actionClass = actionClassMap[risk.action] || "action-allow";

          const chips = risk.examples
            .split(",")
            .map((e) => `<span class="tool-chip">${e.trim()}</span>`)
            .join("");

          row.innerHTML = `
            <span class="risk-tag ${risk.className}">${risk.id}</span>
            <span class="risk-main">
              <span class="risk-title" data-risk="${risk.className}">${risk.title}</span>
              <span class="risk-chips">${chips}</span>
            </span>
            <span class="risk-action ${actionClass}">${risk.action}</span>
          `;
          row.addEventListener("click", () => selectRisk(risk.id));
          riskTable.appendChild(row);
        }
      }

      function renderTimeline() {
        timeline.innerHTML = "";
        for (const phase of PHASES) {
          const item = document.createElement("button");
          item.type = "button";
          item.className = "phase";
          item.dataset.id = phase.id;
          item.innerHTML = `<strong>${phase.title}</strong><span>${phase.short}</span>`;
          item.addEventListener("click", () => selectPhase(phase.id));
          timeline.appendChild(item);
        }
      }

      function applyLens(lens) {
        state.lens = lens;
        for (const pill of document.querySelectorAll("#lensRow .pill")) {
          pill.classList.toggle("active", pill.dataset.lens === lens);
        }
        renderGraph();
      }

      function handleSearchInput(value) {
        state.search = value.trim();
        renderGraph();

        if (!state.search) return;
        const first = NODES.find((node) => matchesSearch(node));
        if (first) {
          selectNode(first.id);
        }
      }

      async function playFlow() {
        if (state.playing) return;
        state.playing = true;
        playFlowButton.textContent = "Playing...";
        playFlowButton.disabled = true;

        for (const step of FLOW_STEPS) {
          if (!state.playing) break;
          selectFlow(step.id);
          await new Promise((resolve) => setTimeout(resolve, 850));
        }

        state.playing = false;
        playFlowButton.textContent = "Play Invocation Path";
        playFlowButton.disabled = false;
      }

      function stopFlowPlayback() {
        state.playing = false;
        playFlowButton.textContent = "Play Invocation Path";
        playFlowButton.disabled = false;
      }

      function downloadSnapshot() {
        const snapshot = {
          generatedAt: new Date().toISOString(),
          architectureElements: NODES,
          edges: EDGES,
          flow: FLOW_STEPS,
          riskTaxonomy: RISKS,
          rolloutPhases: PHASES,
          currentState: {
            selectedId: state.selectedId,
            lens: state.lens,
            focus: state.focus,
            search: state.search,
          },
        };

        const blob = new Blob([JSON.stringify(snapshot, null, 2)], {
          type: "application/json",
        });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = "adaptive-tool-approval-architecture-snapshot.json";
        a.click();
        URL.revokeObjectURL(url);
      }

      function setupEvents() {
        document.getElementById("lensRow").addEventListener("click", (event) => {
          const target = event.target.closest(".pill");
          if (!target) return;
          stopFlowPlayback();
          applyLens(target.dataset.lens);
        });

        searchInput.addEventListener("input", (event) => {
          stopFlowPlayback();
          handleSearchInput(event.target.value);
        });

        clearSearchButton.addEventListener("click", () => {
          searchInput.value = "";
          handleSearchInput("");
          searchInput.focus();
        });

        downloadSnapshotButton.addEventListener("click", downloadSnapshot);

        toggleFocusButton.addEventListener("click", () => {
          state.focus = !state.focus;
          toggleFocusButton.textContent = `Focus: ${state.focus ? "On" : "Off"}`;
          renderGraph();
        });

        resetGraphButton.addEventListener("click", () => {
          stopFlowPlayback();
          state.selectedId = null;
          state.selectedFlow = null;
          state.selectedRisk = null;
          state.selectedPhase = null;
          state.focus = false;
          toggleFocusButton.textContent = "Focus: Off";
          renderGraph();
          updateSelectionStyles();
          renderDetail({
            title: "Select an architectural element",
            subtitle: "Click a graph node, flow step, risk tier, or rollout phase.",
            chips: [],
            blocks: [
              {
                title: "How to use this page",
                list: [
                  "Use Lens filters to focus on runtime, gateway, channels, or operations",
                  "Click nodes for detailed responsibilities, interfaces, and tests",
                  "Use Flow, Risk, and Rollout panels for alternative drilldown paths",
                ],
              },
            ],
          });
        });

        playFlowButton.addEventListener("click", playFlow);

        document.addEventListener("keydown", (event) => {
          if (event.key === "/" && document.activeElement !== searchInput) {
            event.preventDefault();
            searchInput.focus();
            searchInput.select();
            return;
          }

          if (event.key.toLowerCase() === "f") {
            state.focus = !state.focus;
            toggleFocusButton.textContent = `Focus: ${state.focus ? "On" : "Off"}`;
            renderGraph();
          }

          if (event.key === "ArrowRight" || event.key === "ArrowLeft") {
            const visibleNodes = NODES.filter((node) => matchesLens(node) && matchesSearch(node));
            if (!visibleNodes.length) return;
            const currentIndex = visibleNodes.findIndex((node) => node.id === state.selectedId);
            const direction = event.key === "ArrowRight" ? 1 : -1;
            const nextIndex =
              currentIndex < 0
                ? 0
                : (currentIndex + direction + visibleNodes.length) % visibleNodes.length;
            selectNode(visibleNodes[nextIndex].id);
          }
        });
      }

      function init() {
        renderFlow();
        renderRisks();
        renderTimeline();
        setupEvents();
        applyLens("all");
        selectNode("orchestrator");
      }

      init();
    </script>
  </body>
</html>
